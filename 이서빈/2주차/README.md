# 02. 상호작용 추가하기 👥

- 화면의 일부 요소는 사용자의 입력에 따라 업데이트 됨
- State
    - React에서는 시간에 따라 변화하는 데이터
    - 어떠한 컴포넌트에든 추가할 수 있으며, 필요에 따라 업데이트할 수도 있음

## 이벤트에 대한 응답 💬

- React에서는 JSX에 *이벤트 핸들러*를 추가할 수 있음

### 이벤트 핸들러 ❓

**사용자 상호작용에 따라 유발되는 사용자 정의 함수**

![image.png](..%2F..%2F..%2F..%2F..%2FDownloads%2Fimage.png)

[https://blog.knoldus.com/react-events/](https://blog.knoldus.com/react-events/)

내장 컴포넌트는 내장 브라우저 이벤트만 지원

↔ 사용자 정의 컴포넌트는 컴포넌트 이벤트 핸들러 props의 역할에 맞는 원하는 이름을 사용할 수 있음

### **이벤트 핸들러 특징**

- 주로 컴포넌트 내부에서 정의됨 (선택)
- handle로 시작하고 그 뒤에 이벤트명을 붙인 함수명을 가짐 (선택)

### **주의 ⚠️**

- 이벤트 핸들러로 전달한 함수들은 호출이 아닌 전달되어야 함

| 함수를 전달하기 (올바른 예시) | 함수를 호출하기 (잘못된 예시) |
| --- | --- |
| <button onClick={handleClick}> | <button onClick={handleClick()}> |

| 함수를 전달하기 (올바른 예시) | 함수를 호출하기 (잘못된 예시) |
| --- | --- |
| <button onClick={() => alert('...')}> | <button onClick={alert('...')}> |

### **중요 ⭐️**

이벤트 핸들러에 적절한 HTML 태그를 사용하고 있는지 확인

### 이벤트 전파

- 이벤트 핸들러는 해당 컴포넌트가 가진 어떤 자식 컴포넌트의 이벤트를 수신할 수도 있음
- “bubble” 되거나 “전파된다”
- 이벤트는 발생한 지점에서 시작하여 트리를 따라 위로 전달됨

### 전파 멈추기

- 이벤트 핸들러는 **이벤트 오브젝트**를 유일한 매개변수로 받음
- “event”를 의미하는 `e`로 호출되는 것이 일반적
- 이벤트 오브젝트는 전파를 멈출 수 있게 해줌
    - `e.stopPropagation()`를 호출

### **주의 ⚠️**

- 부여된 JSX 태그 내에서만 실행되는 `onScroll`을 제외한 React 내의 모든 이벤트는 전파됩니다.

### 참고 💌

****버블링 vs 캡처링****

[https://ko.javascript.info/bubbling-and-capturing](https://ko.javascript.info/bubbling-and-capturing)

**버블링(bubbling)**

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작함
- 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작함

![image2.png](..%2F..%2F..%2F..%2F..%2FDownloads%2Ftmp%2Fimage2.png)

**캡처링(capturing)**

- 이벤트가 하위 요소로 전파되는 단계
- 버블링과는 반대로 최상위 태그에서 해당 태그를 찾아 내려감

![image3.png](..%2F..%2F..%2F..%2F..%2FDownloads%2Ftmp%2Fimage3.png)

**표준 [DOM 이벤트](http://www.w3.org/TR/DOM-Level-3-Events/)에서 정의한 이벤트 흐름엔 3가지 단계**

1. 캡처링 단계 – 이벤트가 하위 요소로 전파되는 단계
2. 타깃 단계 – 이벤트가 실제 타깃 요소에 전달되는 단계
3. 버블링 단계 – 이벤트가 상위 요소로 전파되는 단계
    
    ![image4.png](..%2F..%2F..%2F..%2F..%2FDownloads%2Ftmp%2Fimage4.png)

> 버블링은 전파를 막을 수 있지만 캡처링은 막을 수는 없다!
> 

### 요약 💗

- `<button>`과 같은 요소에 함수를 prop으로 전달하여 이벤트를 핸들링할 수 있습니다.
- 이벤트 핸들러는 **호출이 아니라** 전달만 가능합니다! `onClick={handleClick()}`이 아니라 `onClick={handleClick}`입니다.
- 이벤트 핸들러 함수는 별개의 함수 혹은 인라인 형태로 정의할 수 있습니다.
- 이벤트 핸들러는 컴포넌트 내부에서 정의되기에 다른 prop에 접근할 수 있습니다.
- 이벤트 핸들러는 부모에서 선언하여 자식에게 prop으로 전달할 수 있습니다.
- 사용자 정의 이벤트 핸들러의 이름을 애플리케이션에 특화된 이름으로 명명할 수 있습니다.
- 이벤트는 위쪽으로 전파됩니다. 첫 번째 매개변수로 `e.stopPropagation()`를 호출하여 방지할 수 있습니다.
- 이벤트는 의도치 않은 기본 브라우저 동작을 유발할 수 있습니다. `e.preventDefault()`를 호출하여 방지할 수 있습니다.
- 명시적으로 이벤트 핸들러 prop을 자식 핸들러에서 호출하는 것은 전파에 대한 좋은 대안이 될 수 있습니다.

## ****State: 컴포넌트의 메모리 💻****

- 상호작용에 따라 컴포넌트는 종종 화면에 표시되는 내용을 변경해야 함
- React에서 컴포넌트별 메모리 = *state*
- `[useState](https://ko.react.dev/reference/react/useState)` Hook을 사용하면 컴포넌트에 state를 추가할 수 있음

### Hooks ❓

[https://ko.legacy.reactjs.org/docs/hooks-overview.html](https://ko.legacy.reactjs.org/docs/hooks-overview.html)

- 컴포넌트가 React의 주요 기능을 사용할 수 있도록 해주는 특별한 함수
- `useState` Hook을 사용하면 state 변수를 선언할 수 있음
- `useState`는 초기 state를 인자로 받음
- 현재 상태와 상태를 업데이트할 수 있는 상태 설정 함수를 배열에 담아 반환함

### **요약** 💗

- 컴포넌트가 렌더링 간에 어떤 정보를 “기억”해야 할 때 state 변수를 사용합니다.
- state 변수는 `useState` 훅을 호출하여 선언합니다.
- 훅은 use로 시작하는 특별한 함수들입니다. 이들은 state와 같은 React 기능에 “연결”할 수 있도록 해줍니다.
- 훅은 import와 마찬가지로 반드시 호출되어야 합니다. `useState`를 포함한 훅을 호출하는 것은 컴포넌트나 다른 훅의 최상위 수준에서만 유효합니다.
- `useState` 훅은 현재 state와 이를 업데이트할 함수로 이루어진 한 쌍을 반환합니다.
- 여러 개의 state 변수를 가질 수 있습니다. React 내부에서는 그들을 순서대로 매칭합니다.
- state는 컴포넌트에 비공개입니다. 두 곳에서 렌더링하더라도 각각의 복사본은 고유한 state를 가집니다.

## ****렌더링과 반영 ⚔️****

컴포넌트는 화면에 표시되기 전에 React에 의해 렌더링 되어야 함

1. 렌더링 **트리거**
2. 컴포넌트 **렌더링**
3. DOM에 **커밋**

![image5.png](..%2F..%2F..%2F..%2F..%2FDownloads%2Ftmp%2Fimage5.png)

### 1단계: 렌더링 트리커

1. 컴포넌트의 **초기 렌더링인 경우**
2. 컴포넌트의 **state가 업데이트된 경우**

### ****2단계: React 컴포넌트 렌더링****

**“렌더링”은 React에서 컴포넌트를 호출하는 것**

1. **초기 렌더링에서** React는 루트 컴포넌트를 호출
2. **이후 렌더링에서** React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출

### **주의 ⚠️**

렌더링은 항상 [순수한 계산](https://ko.react.dev/learn/keeping-components-pure)

- **동일한 입력에는 동일한 출력**
- **이전의 state를 변경해서는 안됨**

### ****3단계: React가 DOM에 변경사항을 커밋****

컴포넌트를 렌더링(호출)한 후 React는 DOM을 수정함

**React는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경함**

### **요약** 💗

- React 앱의 모든 화면 업데이트는 세 단계로 이루어집니다.
    1. 트리거
    2. 렌더링
    3. 커밋
- Strict Mode를 사용하여 컴포넌트에서 실수를 찾을 수 있습니다.
- 렌더링 결과가 이전과 같으면 React는 DOM을 건드리지 않습니다.

## ****snapshot으로서의 state 🖥️****

- React의 state는 snapshot과 유사하게 동작
- 상태 갱신 → 리렌더링 유발

## ****state 업데이트를 연속으로 대기열에 추가하기 🛠️****

state를 설정하면 리렌더링이 유발되지만, 이미 실행 중인 코드에서는 변경되지 않음

⇒ state를 설정할 때 *updater function*을 전달하는 방식을 통해 해결

### **요약** 💗

- state를 설정하더라도 기존 렌더링의 변수는 변경되지 않으며, 대신 새로운 렌더링을 요청합니다.
- React는 이벤트 핸들러가 실행을 마친 후 state 업데이트를 처리합니다. 이를 batching 이라고 합니다.
- 하나의 이벤트에서 일부 state를 여러 번 업데이트하려면 `setNumber(n => n + 1)` 업데이터 함수를 사용할 수 있습니다.

## ****state 내 객체 업데이트 💡****

- State는 객체를 포함하여 모든 종류의 JavaScript 타입을 관리할 수 있음
- But! React state에 있는 개체와 배열을 직접 변경해서는 안됨
- 객체나 배열을 업데이트할 때는 새로운 객체를 생성하거나 기존 객체의 복사본을 만들어서 상태를 업데이트 해야함
    - 일반적으로 변경하려는 객체나 배열을 복사하기 위해 `...` 전개 구문을 사용

### **요약** 💗

- 리액트의 모든 state를 불변한 것으로 대하세요.
- state에 객체를 저장할 때, 객체를 변경하는 것은 렌더링을 발생시키지 않으며 이전 렌더 “스냅샷”의 state를 바꿀 것입니다.
- 객체를 변경하는 대신 *새로운* 객체를 생성하여 state를 설정함으로써 리렌더링을 일으키세요.
- 객체의 복사본을 만들기 위해 `{...obj, something: 'newValue'}` 객체 전개 구문을 사용할 수 있습니다.
- 전개 구문은 얕습니다. 그것은 한 레벨 깊이만 복사합니다.
- 중첩된 객체를 업데이트하기 위해서는 변경하는 부분에서부터 시작하여 객체의 모든 항목의 복사본을 만들어야 합니다.
- 반복적인 복사 코드를 줄이기 위해서 Immer를 사용하세요.

## ****state 내 배열 업데이트 ⚙️****

- 배열 또한 state에 저장될 때 읽기 전용으로 다루어야 하는 가변 JavaScript 객체
- 과거에 생성된 이벤트 핸들러는 그것이 생성된 렌더링 시점의 state 값을 갖습니다.
- 렌더링 된 JSX에 대해 생각하는 방식과 유사하게 이벤트 핸들러에서 state를 대체할 수 있습니다.
- 모든 렌더링(및 그 안의 함수)은 항상 React가 그 렌더링에 제공한 state의 스냅샷을 “보게” 됩니다.
- 변수와 이벤트 핸들러는 다시 렌더링해도 “살아남지” 않습니다. 모든 렌더링에는 고유한 이벤트 핸들러가 있습니다.
- `useState`를 호출하면 React는 해당 렌더링에 대한 state의 스냅샷을 제공합니다.
- React는 컴포넌트 외부에 마치 선반에 보관하듯 state를 저장합니다.
- state를 설정하면 새 렌더링을 요청합니다.

### **요약** 💗

- 배열을 state로 만들 수 있지만 변경하면 안됩니다.
- 배열을 변경하는 대신 배열의 *새로운* 버전을 만들고, state를 업데이트 해야합니다.
- `[...arr, newItem]` 배열 전개 구문을 사용하여 새 항목을 포함한 배열을 생성할 수 있습니다.
- `filter()`와 `map()`을 사용하여 필터링된 항목들이나 변환된 항목들을 가진 배열을 만들 수 있습니다.
- Immer를 사용하여 코드 간결성을 유지할 수 있습니다.