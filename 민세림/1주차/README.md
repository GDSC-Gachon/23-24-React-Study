## 📌 목차
**0. UI 표현하기**
- 0.1. 첫 컴포넌트
- 0.2. 컴포넌트 Import 및 Export 하기
- 0.3. JSX로 마크업 작성하기
- 0.4. JSX에서 중괄호를 이용하여 JavaScript 사용하기
- 0.5. 컴포넌트에 Props 전달하기
- 0.6. 조건부 렌더링
- 0.7. 리스트 렌더링
- 0.8. 컴포넌트 순수하게 유지하기

**1. 첫 번째 컴포넌트**
- 1.1. 컴포넌트: UI 구성 요소
- 1.2. 컴포넌트 정의하기
- 1.3. 컴포넌트 사용하기
- 1.4. 브라우저에 표시되는 내용
- 1.5. 컴포넌트 중첩 및 구성

**2. 컴포넌트 import 및 export 하기**
- 2.1. Root 컴포넌트란
- 2.2. 컴포넌트를 import 하거나 export 하는 방법
- 2.3. 한 파일에서 여러 컴포넌트를 import 하거나 export 하는 방법

**3. JSX로 마크업 작성하기**
- 3.1. JSX: JavaScript에 마크업 넣기
- 3.2. HTML을 JSX로 변환하기
- 3.3. JSX의 규칙

**4. 중괄호가 있는 JSX 안에서 자바스크립트 사용하기**
- 4.1. 따옴표로 문자열 전달하기
- 4.2. 중괄호 사용하기: JavaScript 세계로 연결하는 창
- 4.3. 중괄호를 사용하는 곳
- 4.4. “이중 중괄호” 사용하기: JSX의 CSS와 다른 객체
- 4.5. JavaScript 객체와 중괄호에 대해서 더 알아보기

**5. 컴포넌트에 props 전달하기**
- 5.1. 친숙한 props
- 5.2. 컴포넌트에 props 전달하기
- 5.3. prop의 기본값 지정하기
- 5.4. JSX spread 문법으로 props 전달하기
- 5.5. 자식을 JSX로 전달하기
- 5.6. 시간에 따라 props가 변하는 방식

**6. 조건부 렌더링**
- 6.1. 조건부로 JSX 반환하기
- 6.2. 조건부로 `null`을 사용하여 아무것도 반환하지 않기
- 6.3. 조건부로 JSX 포함시키기
- 6.4. 삼항 조건 연산자 (`? :`)
- 6.5. 변수에 조건부로 JSX를 할당하기

**7. 리스트 렌더링**
- 7.1. 배열을 데이터로 렌더링하기
- 7.2. 배열의 항목들을 필터링하기
- 7.3. `key`를 사용해서 리스트 항목을 순서대로 유지하기
- 7.4. `key`를 가져오는 곳
- 7.5. key 규칙
- 7.6. React에 key가 왜 필요한 이유는 무엇인가요?

**8. 컴포넌트를 순수하게 유지하기**
- 8.1. 순수성: 공식으로서의 컴포넌트
- 8.2. 사이드 이펙트: 의도하지(않은) 결과
- 8.3. 지역 변형: 컴포넌트의 작은 비밀
- 8.4. 부작용을 *일으킬 수 있는* 지점

## 📌 UI 표현하기 > 스터디 질문
### 🔍 질문1. 순수성이란 무엇인가?
순수성은 순수함수가 지니고 있는 특성이라고 말할 수 있습니다. 여기서 순수성의 조건으로는 다음과 같이 말할 수 있습니다.
- 자신의 일에 집중
- 같은 입력, 같은 출력
입니다.

위 내용에 대해 설명해보자면, 먼저 `자신의 일에 집중한다는 것`은 함수가 호출되기 전에 존재했던 어떤 객체나 변수는 변경하지 않는 다는 의미입니다. 또한 `같은 입력, 같은 출력`은 같은 입력이 주어졌다면 같은 결과를 반화해야 한다는 의미입니다.

코드로 예를 들어 보자면,
``` js
function double(number) {
  return 2 * number;
}
```
무슨 값을 입력하더라도 출력은 해당 입력값의 2배가 된다는 점에서 같은 입력, 같은 출력 조건에 충족한다고 볼 수 있습니다.

순수 함수는 다음과 같은 효과를 가지고 있습니다.
1. 다른 환경에서도 컴포넌트 실행 가능 : 동일한 입력에 대해 동일한 결과를 반환하기 때문에 하나의 컴포넌트는 많은 사용자 요청 처리가 가능해짐
2. 입력이 변경되지 않은 컴포넌트 렌더링 건너뛰어 성능을 향상시킬 수 있음. 따라서 순수 함수는 항상 동일한 경과를 반환하므로 캐시하기에 안전함.
3. 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되는 경우 React는 오래된 렌더링을 완료하는 데 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있음. 순수함은 언제든지 연산을 중단하는 것을 안전하게 함.

## 🔍 질문2. JSX를 사용하는 이유에 대해 설명하시오
먼저 JSX에 대해 설명해보자면, JSX는 `JavaScript를 확장한 문법`으로 JavaScript 파일을 HTML과 비슷하게 `마크업할 수 있게 해줍니다.`
JSX에는 하나의 루트 엘리먼트로 반환해야 하고 모든 태그는 닫아줘야 하는 문법이 있습니다.
이를 바탕으로 JSX를 사용하는 이유로, 자바스크립트에서 HTML을 작성하듯이 비슷하게 작성할 수 있게 해주는 것이라고 말 할 수 있습니다.

## 🔍 질문3. default와 named export에 대해 설명하시오
JavaScript에서 export는 default와 named export를 통해서 이루어집니다. 한 파일에서 하나의 default export만 존재할 수 있고 named export는 여러개 존재할 수 있습니다.   
보편적으로 한 파일에서 하나의 컴포넌트만 export 할 때 default export 방식을 사용하고 여러 컴포넌트를 export 할 경우엔 named export 방식을 사용합니다.

## 📌 정리
### 0. UI 표현하기
- React : 사용자 인터페이스(UI)를 렌더링하기 위한 JavaScript 라이브러리
- UI : 버튼, 텍스트, 이미지와 같은 작은 요소로 구성

**0.1. 첫 컴포넌트**
- 독립된 UI 조각들
- 마크업을 얹을 수 있는 JavaScript 함수

**0.2. 컴포넌트 Import 및 Export 하기**   

**0.3. JSX로 마크업 작성하기**
- React 컴포넌트
    - React가 브라우저에 렌더링하는 마크업을 포함할 수 있는 JavaScript 함수
    - 마크업을 표현하기 위해 JSX라는 확장된 문법을 사용

```js
export default function TodoList() {
  return (
    // This doesn't quite work!
    <h1>Hedy Lamarr's Todos</h1>
    <img
      src="https://i.imgur.com/yXOvdOSs.jpg"
      alt="Hedy Lamarr"
      class="photo"
    >
    <ul>
      <li>Invent new traffic lights
      <li>Rehearse a movie scene
      <li>Improve spectrum technology
    </ul>
  );
}
```

```js
export default function TodoList() {
  return (
    <>
      <h1>Hedy Lamarr's Todos</h1>
      <img
        src="https://i.imgur.com/yXOvdOSs.jpg"
        alt="Hedy Lamarr"
        className="photo"
      />
      <ul>
        <li>Invent new traffic lights</li>
        <li>Rehearse a movie scene</li>
        <li>Improve spectrum technology</li>
      </ul>
    </>
  );
}
```

**0.4. JSX에서 중괄호를 이용하여 JavaScript 사용하기**
- JSX를 사용하면 JavaScript 파일에 `HTML과 비슷한 마크업을 작성할 수 있어` 렌더링 로직과 콘텐츠를 같은 곳에 둘 수 있음

**0.5. 컴포넌트에 Props 전달하기**
- 모든 부모 컴포넌트는 자식 컴포넌트에 props를 제공하여 정보를 전달
- 객체, 배열, 함수를 포함한 모든 JavaScript 값이 전달될 수 있음

```js
import { getImageUrl } from './utils.js'

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}
```

**0.6. 조건부 렌더링**
- `if` 문, `&&` 및 `? :` 연산자와 같은 자바스크립트 문법을 사용하여 JSX를 조건부로 렌더링
**0.7. ** 리스트 렌더링**
- `filter()`와 `map()`을 함께 사용하면 데이터 배열을 필터링하고 컴포넌트 배열로 변환
- 각 배열 항목마다 `key`를 지정해야 함

**0.8 컴포넌트 순수하게 유지하기**

- **자신의 일만 처리합니다.**
    - 호출되기 전에 존재했던 어떤 객체나 변수도 변경하지 않습니다.
- **입력이 같으면 출력도 같습니다.**
    - 순수 함수는 같은 입력을 받으면 언제나 같은 결과를 반환해야 합니다.

## 1. 첫 번째 컴포넌트

**1.1. 컴포넌트: UI 구성 요소**

- `앱의 재사용 가능한 UI 요소`

**1.2. 컴포넌트 정의하기**

- `마크업으로 뿌릴 수 있는 JavaScript 함수`

**[컴포넌트를 빌드하는 방법]**
- 1단계: 컴포넌트 내보내기
- 2단계: 함수 정의하기
- 3단계: 마크업 추가하기

**1.3. 컴포넌트 사용하기**

**1.4. 브라우저에 표시되는 내용**

**1.5. 컴포넌트 중첩 및 구성**

- 컴포넌트는 다른 컴포넌트를 렌더링할 수 있지만, **그 정의를 중첩해서는 안 됩니다.**

``` md
React를 사용하면 앱의 재사용 가능한 UI 요소인 컴포넌트를 만들 수 있습니다.

React 앱에서 모든 UI는 컴포넌트입니다.

React 컴포넌트는 다음 몇 가지를 제외하고는 일반적인 JavaScript 함수입니다.

컴포넌트의 이름은 항상 대문자로 시작합니다.
JSX 마크업을 반환합니다.
```

## 2. 컴포넌트 import 및 export 하기

**2.1. Root 컴포넌트란**
- 모두 `App.js`라는 **root 컴포넌트 파일**에 존재합
- Next.js처럼 파일 기반으로 라우팅하는 프레임워크일 경우 페이지별로 root 컴포넌트가 다를 수 있음

**2.2. 컴포넌트를 import 하거나 export 하는 방법**
- **보편적으로 한 파일에서 하나의 컴포넌트만 export 할 때 default export 방식을 사용하고 여러 컴포넌트를 export 할 경우엔 named export 방식을 사용**

**2.3. 한 파일에서 여러 컴포넌트를 import 하거나 export 하는 방법**
- 한 파일에서는 단 하나의 default export만 사용할 수 있지만 named export는 여러 번 사용할 수 있습니다.
- named export vs default export

### 요약
- Root 컴포넌트란 무엇인지
- 컴포넌트를 import 하거나 export 하는 방법
- 언제 default 또는 named imports와 exports를 사용할지
- 한 파일에서 여러 컴포넌트를 export 하는 방법

## 3. JSX로 마크업 작성하기
**3.1. JSX: JavaScript에 마크업 넣기**
- *JSX* : JavaScript를 확장한 문법
- Web이 더욱 인터랙티브해지면서, 로직이 내용을 결정하는 경우가 많아졌습니다. 그래서 JavaScript가 HTML을 담당하게 됨.
- **React에서 렌더링 로직과 마크업이 같은 위치에 함께 있게 된 이유**
- HTML과 비슷해 보이지만, 조금 더 엄격하며 동적으로 정보를 표시할 수 있음

**3.2. HTML을 JSX로 변환하기**

**3.3. JSX의 규칙**
1. 하나의 루트 엘리먼트로 반환하기
- 한 컴포넌트에서 여러 엘리먼트를 반환하려면, **하나의 부모 태그로 감싸주세요.**
- `<>`와 `</>`로 대체 가능 : Fragment
2. 모든 태그는 닫아주기
- JSX에서는 태그를 명시적으로 닫아야 함
3. ~~거의~~ 대부분 캐멀 케이스
- JSX는 JavaScript로 바뀌고 JSX에서 작성된 어트리뷰트는 JavaScript 객체의 키가 됨
    - 컴포넌트에서는 종종 어트리뷰트를 변수로 읽고 싶은 경우가 있음
    - JavaScript는 변수명에 제한이 있음
### 요약

- React 컴포넌트는 서로 관련이 있는 마크업과 렌더링 로직을 함께 그룹화합니다.
- JSX는 HTML과 비슷하지만 몇 가지 차이점이 있습니다. 필요한 경우 [변환기](https://transform.tools/html-to-jsx)를 사용할 수 있습니다.
- 오류 메시지는 종종 마크업을 수정할 수 있도록 올바른 방향을 알려줍니다.

## 4. 중괄호가 있는 JSX 안에서 자바스크립트 사용하기

**4.1. 따옴표로 문자열 전달하기**
- `src` 또는 `alt`를 동적으로 지정 시,
    - **`"`와`"`를 `{`와`}`로 바꿔 JavaScript의 값을 사용할 수 있습니다**.

**4.2. 중괄호 사용하기: JavaScript 세계로 연결하는 창**

**4.3. 중괄호를 사용하는 곳**
1. JSX 태그 안의 **문자**: `<h1>{name}'s To Do List</h1>`는 작동하지만, `<{tag}>Gregorio Y. Zara's To Do List</{tag}>`는 작동하지 않습니다.
2. `=` 바로 뒤에 오는 **어트리뷰트**: `src={avatar}`는 `avatar` 변수를 읽지만 `src="{avatar}"`는 `"{avatar}"` 문자열을 전달합니다

**4.4. “이중 중괄호” 사용하기: JSX의 CSS와 다른 객체**
- SX에는 문자열, 숫자 및 기타 JavaScript 표현식뿐만 아니라 객체를 전달 가능
- 중괄호
    - 객체는 `{ name: "Hedy Lamarr", inventions: 5 }`처럼 중괄호로 표시

**4.5. JavaScript 객체와 중괄호에 대해서 더 알아보기**
### 요약
- 따옴표 안의 JSX 어트리뷰트는 문자열로 전달됩니다.
- 중괄호를 사용하면 JavaScript 논리와 변수를 마크업으로 가져올 수 있습니다.
- JSX 태그 내부 또는 어트리뷰트의 `=` 뒤에서 작동합니다.
- `{{` 및 `}}` 는 특별한 문법이 아닙니다. JSX 중괄호 안에 들어 있는 JavaScript 객체입니다.

## 5. 컴포넌트에 props 전달하기
- React 컴포넌트는 props를 이용해 서로 통신
- 모든 부모 컴포넌트는 props를 줌으로써 몇몇의 정보를 자식 컴포넌트에게 전달

**5.1. 친숙한 props**
- JSX 태그에 전달하는 정보

**5.2. 컴포넌트에 props 전달하기**
- 1단계: 자식 컴포넌트에 props 전달하기
- 2단계: 자식 컴포넌트 내부에서 props 읽기
- 조절할 수 있는 손잡이
- 함수의 인수와 동일한 역할
- 컴포넌트에 대한 유일한 인자

`구조 분해 할당`

**5.3. prop의 기본값 지정하기**
- 값이 지정되지 않았을 때, prop에 기본값을 주길 원한다면, 변수 바로 뒤에 `=` 과 함께 기본값을 넣어 구조 분해 할당을 해줄 수 있음

**5.4. JSX spread 문법으로 props 전달하기**

- props를 직접 사용하지 않기 때문에 보다 간결한 “spread” 문법을 사용하는 것이 합리적
- **spread 문법은 제한적으로 사용 추천**.

**5.5. 자식을 JSX로 전달하기**

**5.6. 시간에 따라 props가 변하는 방식**
- **컴포넌트가 시간에 따라 다른 props를 받을 수 있음을 보여줌.**
- props는 컴퓨터 과학에서 “변경할 수 없다”라는 의미의 [불변성](https://en.wikipedia.org/wiki/Immutable_object)

### 요약
- Props를 전달하려면 HTML 어트리뷰트를 사용할 때와 마찬가지로 JSX에 props를 추가합니다.
- Props를 읽으려면 `function Avatar({ person, size })` 구조 분해 할당 문법을 사용합니다.
- `size = 100` 과 같은 기본값을 지정할 수 있으며, 이는 누락되거나 `undefined` 인 props에 사용됩니다.
- 모든 props를 `<Avatar {...props} />`로 전달할 수 있습니다. JSX spread 문법을 사용할 수 있지만 과도하게 사용하지 마세요!
- `<Card><Avatar /></Card>`와 같이 중첩된 JSX는 `Card`컴포넌트의 자식 컴포넌트로 나타납니다.
- Props는 읽기 전용 스냅샷으로, 렌더링 할 때마다 새로운 버전의 props를 받습니다.
- Props는 변경할 수 없습니다. 상호작용이 필요한 경우 state를 설정해야 합니다.

## 6. 조건부 렌더링
- `if` 문, `&&` 및 `? :` 연산자와 같은 자바스크립트 문법을 사용하여 조건부로 JSX를 렌더링

**6.1. 조건부로 JSX 반환하기**

**6.2. 조건부로 `null`을 사용하여 아무것도 반환하지 않기**

**6.3. 조건부로 JSX 포함시키기**

**6.4. 삼항 조건 연산자 (`? :`)**

**6.5. 논리 AND 연산자 (`&&`)**

**6.6. 변수에 조건부로 JSX를 할당하기**

## 요약
- React에서 JavaScript로 분기 로직을 제어합니다.
- 조건부로 `if` 문과 함께 JSX 식을 반환할 수 있습니다.
- 조건부로 일부 JSX를 변수에 저장한 다음 중괄호를 사용하여 다른 JSX에 포함할 수 있습니다.
- JSX에서 `{cond ? <A /> : <B />}`는 *“`cond`이면 `<A />`를 렌더링하고, 그렇지 않으면 `<B />`를 렌더링합니다.”* 를 의미합니다.
- JSX에서 `{cond && <A />}`는 *“`cond`이면, `<A />`를 렌더링하되, 그렇지 않으면 아무것도 렌더링하지 않습니다.”* 를 의미합니다.
- 위 예시는 흔한 방법이지만, `if`를 선호한다면 사용하지 않아도 됩니다.

## 7. 리스트 렌더링

**7.1. 배열을 데이터로 렌더링하기**
- 해당 데이터를 JavaScript 객체와 배열에 저장하고 `[map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)`과 `[filter()](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)` 같은 메서드를 사용하여 해당 객체에서 컴포넌트 리스트를 렌더링할 수 있음

배열에서 항목 리스트를 생성하는 방법

1. 데이터를 배열로 **이동**합니다.
2. `people`의 요소를 새로운 JSX 노드 배열인 `listItems`에 **매핑**합니다.
3. `<ul>`로 래핑된 컴포넌트의 `listItems`를 **반환**합니다.

**7.2. 배열의 항목들을 필터링하기**

**7.3. `key`를 사용해서 리스트 항목을 순서대로 유지하기**
key
- 각 컴포넌트가 어떤 배열 항목에 해당하는지 React에 알려주어 나중에 일치시킬 수 있도록 함

**7.4. `key`를 가져오는 곳**
- **데이터베이스의 데이터**
- **로컬에서 생성된 데이터**

**7.5. key 규칙**
- **key는 형제 간에 고유해야 합니다.**
- **key는 변경되어서는 안 되며**

**7.6. React에 key가 왜 필요한 이유는 무엇인가요?**

### 요약
- 컴포넌트에서 배열이나 객체와 같은 데이터 구조로 데이터를 이동하는 방법
- JavaScript의 `map()`을 사용하여 유사한 컴포넌트 집합을 생성하는 방법
- JavaScript의 `filter()`를 사용하여 필터링된 항목의 배열을 생성하는 방법
- 컬렉션에서 각 컴포넌트에 `key`를 설정하여 위치나 데이터가 변경되더라도 React가 각 컴포넌트를 추적할 수 있도록 하는 이유와 방법

## 8. 컴포넌트를 순수하게 유지하기

**8.1. 순수성: 공식으로서의 컴포넌트**

**8.2. 사이드 이펙트: 의도하지(않은) 결과**

**8.3. 지역 변형: 컴포넌트의 작은 비밀**

**8.4. **부작용을 *일으킬 수 있는* 지점**
### 요약
- 컴포넌트는 순수해야만 합니다. 이것은 두가지를 의미합니다.
    - **자신의 일에 집중합니다.** 렌더링전에 존재했던 객체나 변수를 변경하지 않아야 합니다.
    - **같은 입력, 같은 결과물.** 입력이 같을 경우, 컴포넌트는 항상 같은 JSX를 반환해야 합니다.
- 렌더링은 언제든지 발생할 수 있으므로 컴포넌트는 서로의 렌더링 순서에 의존하지 않아야 합니다.
- 컴포넌트가 렌더링을 위해 사용되는 입력을 변형해서는 안 됩니다. 여기에는 프로퍼티즈, 상태, 그리고 컨텍스트가 포함됩니다. 화면을 업데이트하려면 기존 객체를 변환하는 대신 [상태를 “설정”](https://ko.react.dev/learn/state-a-components-memory)하십시오.
- 반환하는 JSX에서 컴포넌트의 로직을 표현하기 위해 노력하십시오. “무언가를 변경”해야 할 경우 일반적으로 이벤트 핸들러에서 변경하고 싶을 것입니다. 마지막 수단으로 `useEffect`를 사용할 수 있습니다.
- 순수 함수를 작성하는 것은 약간의 연습이 필요하지만, React 패러다임의 힘을 풀어줍니다.