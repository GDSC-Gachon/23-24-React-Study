# 리액트 공식문서 스터디 2주차

## 상호작용 추가하기

- `state` 시간이 지남에 따라 변하는 데이터
    - 모든 컴포넌트에 추가하고 업데이트할 수 있다
    - `useState` 훅 사용하기 - 특수함수, state변수를 선언할 수 있다
    - = 리액트에게 컴포넌트가 무언가 기억하기를 원한다고 말하기

### 이벤트에 응답하기

- 이벤트 핸들러 함수는 컴포넌트 안에 정의
- `handle`로 시작하는 이름 뒤에 이벤트 이름이 오도록
- 인라인 (함수 짧을 때 편리) or 화살표 함수 사용
- 이벤트 핸들러 props는 `on`으로 시작, 뒤에 대문자
- 이벤트 핸들러는 이벤트 객체를 유일한 인수로 받는다 `e`

### State: 컴포넌트의 메모리

- state: 기억하는 컴포넌트별 메모리
- *지역 변수는 렌더링 간에 유지되지 않음 → 렌더링 사이에 데이터유지 필요
- useState 훅을 사용해 state변수 선언하고, 리액트가 컴포넌트를 다시 렌더링 할 수 있도록 촉발시키기(state 설정자 함수)
- hook: use로 시작하는 함수, 렌더링 중일 때만 사용할 수 있다
- state는 컴포넌트 인스턴스에 지역적, 각 사본은 격리된 상태, 부모컴포넌트도 변경할 수 X, 비공개

### 랜더링하고 커밋하기

- 컴포넌트들은 React에서 렌더링한 뒤 화면에 표시
1. 렌더링 발동(촉발)
- 첫 렌더링 때, state가 업데이트될 때(리렌더링)
1. 컴포넌트 렌더링
- 렌더링: 리액트에서 컴포넌트를 호출하는 것
- 첫 렌더링: 루트 컴포넌트 호출
- 이후 렌더링: 렌더링 발동된 함수 컴포넌트 호출(재귀적)
1. DOM에 커밋
- 컴포넌트를 렌더링(호출)한 뒤 리액트는 DOM을 수정
    - 렌더링 결과가 전과 같으면 수정하지 않는다
- strictmode 사용하면 컴포넌트의 실수를 찾을 수 있다

### 스냅샷으로서의 state

- state 설정 → 새 렌더링 요청
- JS 변수와 달리 React state는 스냅샷처럼 동작
- 렌더링은 그 시점의 스냅샷!
    - prop, 이벤트 핸들러, 로컬 변수는 모두 렌더링 당시의 state를 사용해 계산
- 리렌더링 절차
    - 함수 다시 호출
    - 새로운 jsx 스냅샷 반환
    - 스냅샷과 일치하도록 화면 업데이트
- 컴포넌트 외부에 state 저장
- state 변수는 변경되지 않고 리렌더링된다.
- state 변수의 값은 렌더링 내에서 절대 변경되지 않는다(고정)
- 과거의 생성된 이벤트 핸들러는 그것이 생성된 렌더링 시점의 state 값 갖는다

### 여러 state업데이트를 큐에 담기

- state 변수 설정 → 다음 렌더링에 큐(대기열)에 들어감
- 여러 작업을 시행하고 싶으면 state 업데이트 배치 고려하기
- 리액트는 state 업데이트 하기 전에 이벤트 핸들러의 모든 코드가 실행될때까지 기다림 → 함수 호출이 완료된 이후에만 일어난다
- 리액트는 이벤트 핸들러가 실행을 마친 후 state 업데이트를 처리 = 일괄배칭
- 일괄처리(배칭)은 많은 리렌더링 없이도 리액트앱을 빠르게 실행할 수 있게 한다.
    - 안전한 경우에만 일괄처리를 수행해, 클릭이 어려번 되어 중복된 양식이 제출되지 않도록
- 이벤트 핸들러 완료→ 리렌더링 실행 → (업데이터 함수 실행)→ 큐 처리
    - 업데이터 함수는 순수해야 하고, 결과만 반환해야한다.

### 객체 state 업데이트

- state는 객체를 포함해 어떤 종류의 js값 저장 가능
- 객체 업데이트 위해서는 새로운 객체 생성 뒤, 해당 복사본 사용하도록 설정
- 변이: 기술적으로 객체 자체의 내용을 변경하는 것
- 하지만 state의 객체는 불변하는 것처럼 취급, 직접 변이하는 대신, 교체하기
- ⇒ state에 넣는 모든 js 객체를 읽기 전용으로 취급하기
- 객체 전개 구문을 사용하면 모든 속성을 개별적으로 복사할 필요 X
    - 하지만 **************************얕은 구문**************************이므로 한단계 깊이만 복사
- Immer의 draft: 프록시 유형의 객체, 기록하는 역할, 자유로운 수정 가능
    - lmmer는 내부적으로 변경 사항과 편집 내용이 포함된 새로운 객체 생성
    - state에 중첩이 있고, 코드 반복되는 경우 업데이트 핸들러를 간결하게 유지하는데 유용

### 배열 state 업데이트

- state 내에서 배열은 변경이 불가능해요
- 객체와 같이 배열도 업데이트하려면 새 배열 만들어 사용하도록 state 설정
- state 배열은 재할당 불가, 배열 변이 메서드 사용 불가
- map(): 새로운 배열을 만들거나 배열의 일부 또는 모든 항목을 변경하기 위해 사용
- `slice()` 매서드: 배열의 조각을 잘라내, 새 항목과 원래 배열을 펼치는 배열 생성
- 배열을 복사해도 배열 내부의 기존 항목을 직접 변이할 수는 없다
- 중첩된 state 업데이트 시 업데이트시점부터 최상위 시점까지 복사본 만들기
- 변이는 방금 만든 객체만 가능
- Immer를 사용해 반복적인 중첩배열을 효율적으로 사용하기
